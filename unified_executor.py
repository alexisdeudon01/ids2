#!/usr/bin/env python3
"""
=============================================================================
UNIFIED EXECUTION SCRIPT - Auto-generated by Workflow Analyzer
=============================================================================
Ce script ex√©cute tous les scripts du projet dans l'ordre optimal.
G√©n√©r√© le: 2026-02-04 20:27:18
=============================================================================
"""

import os
import sys
import subprocess
import time
import signal
import fcntl
import shutil
from pathlib import Path
from enum import Enum, auto
from dataclasses import dataclass
from typing import Optional, List, Callable
import logging

# Configuration du logging
def setup_logging(log_file: str = 'unified_execution.log'):
    """Setup logging with validated log file path."""
    log_path = Path(log_file)
    # Ensure log directory exists
    log_path.parent.mkdir(parents=True, exist_ok=True)
    # Validate we can write to log file
    try:
        log_path.touch(exist_ok=True)
    except (IOError, PermissionError) as e:
        print(f"‚ö†Ô∏è  Warning: Cannot write to log file {log_path}: {e}")
        log_file = '/tmp/unified_execution.log'
        log_path = Path(log_file)
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s | %(levelname)-8s | %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler(str(log_path))
        ]
    )
    return logging.getLogger(__name__)

log = setup_logging()

# =============================================================================
# FSM STATES
# =============================================================================

class State(Enum):
    START = auto()
    UNIFIED_EXECUTOR_PY = auto()
    SETUP_SH = auto()
    02_INSTALL_BASE_SH = auto()
    SETUP_VENV_SH = auto()
    00_CHECK_APT_SOURCES_SH = auto()
    01_UPDATE_UPGRADE_SH = auto()
    05_INSTALL_DOCKER_SH = auto()
    06_INSTALL_SURICATA_SH = auto()
    07_INSTALL_PIGPIO_SH = auto()
    08_INSTALL_SQLITE_SH = auto()
    09_CONFIGURE_NETWORK_SH = auto()
    WORKFLOW_ANALYZER_PY = auto()
    10_INSTALL_BACKEND_DEPS_SH = auto()
    03_INSTALL_PYTHON_SH = auto()
    04_INSTALL_NODE_SH = auto()
    MAIN_PY = auto()
    11_INSTALL_FRONTEND_DEPS_SH = auto()
    DEPLOY_PY = auto()
    SUCCESS = auto()
    ERROR = auto()

# =============================================================================
# CONFIGURATION
# =============================================================================

@dataclass
class StepConfig:
    name: str
    script: str
    state: State
    description: str
    timeout: int = 300
    can_fail: bool = True
    on_failure: str = "abort"  # abort, skip, retry
    max_retries: int = 3
    inputs: List[str] = None
    outputs: List[str] = None

EXECUTION_STEPS: List[StepConfig] = [
    StepConfig(
        name="unified_executor.py",
        script="unified_executor.py",
        state=State.UNIFIED_EXECUTOR_PY,
        description="A unified execution orchestrator that runs all project scripts in optimal order with FSM state manag",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['project_dir', 'EXECUTION_STEPS configuration', 'environment variables'],
        outputs=['unified_execution.log', 'execution state changes', 'orchestrated script results']
    ),
    StepConfig(
        name="setup.sh",
        script="setup.sh",
        state=State.SETUP_SH,
        description="Remote deployment script that packages and installs an IDS (Intrusion Detection System) dashboard on",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['PI_HOST (IP address)', 'PI_USER (SSH username)', 'PI_PASS (SSH password)'],
        outputs=['ids-dashboard.tar.gz archive', 'Remote directory structure on Pi', 'Installed services on Pi']
    ),
    StepConfig(
        name="02-install-base.sh",
        script="02-install-base.sh",
        state=State.02_INSTALL_BASE_SH,
        description="Installs base system packages required for the project using apt-get with non-interactive mode.",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'internet connection', 'debian/ubuntu system'],
        outputs=['ca-certificates', 'curl', 'gnupg']
    ),
    StepConfig(
        name="setup_venv.sh",
        script="setup_venv.sh",
        state=State.SETUP_VENV_SH,
        description="Sets up a Python virtual environment named 'venv', installs dependencies from requirements.txt if pr",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['requirements.txt (optional)', '.gitignore file', 'python3 binary'],
        outputs=['venv/ directory with virtual environment', 'installed Python packages', 'updated .gitignore file']
    ),
    StepConfig(
        name="00-check-apt-sources.sh",
        script="00-check-apt-sources.sh",
        state=State.00_CHECK_APT_SOURCES_SH,
        description="Validates that APT package manager sources are properly configured by checking for existence of sour",
        timeout=5,
        can_fail=True,
        on_failure="abort",
        inputs=['/etc/apt/sources.list', '/etc/apt/sources.list.d/', 'APT configuration files'],
        outputs=['console messages in French', 'exit status (0=success, 1=failure)']
    ),
    StepConfig(
        name="01-update-upgrade.sh",
        script="01-update-upgrade.sh",
        state=State.01_UPDATE_UPGRADE_SH,
        description="Updates APT package lists and upgrades all installed Debian/Ubuntu packages to their latest versions",
        timeout=1800,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'internet connection', 'APT package manager'],
        outputs=['updated package lists in /var/lib/apt/lists/', 'upgraded system packages', 'updated package cache']
    ),
    StepConfig(
        name="05-install-docker.sh",
        script="05-install-docker.sh",
        state=State.05_INSTALL_DOCKER_SH,
        description="Installs Docker Engine via apt with GPG key verification and adds user to docker group. Enables Dock",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['INSTALL_USER env var', 'SUDO_USER env var', 'USER env var'],
        outputs=['docker service enabled', 'docker group membership', 'Docker Engine installed']
    ),
    StepConfig(
        name="06-install-suricata.sh",
        script="06-install-suricata.sh",
        state=State.06_INSTALL_SURICATA_SH,
        description="Installs Suricata network intrusion detection system and updates its rule sets on Debian/Ubuntu syst",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root privileges', 'internet connectivity', 'apt package manager'],
        outputs=['suricata binary installed', 'suricata-update tool', 'updated threat detection rules']
    ),
    StepConfig(
        name="07-install-pigpio.sh",
        script="07-install-pigpio.sh",
        state=State.07_INSTALL_PIGPIO_SH,
        description="Downloads, compiles, and installs pigpio library from source code with systemd service setup for GPI",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['internet connection', 'PIGPIO_ARCHIVE_URL environment variable', 'apt package manager'],
        outputs=['pigpio library binaries', 'pigpiod daemon', 'systemd service file']
    ),
    StepConfig(
        name="08-install-sqlite.sh",
        script="08-install-sqlite.sh",
        state=State.08_INSTALL_SQLITE_SH,
        description="Installs SQLite3 database engine using apt-get package manager on Debian/Ubuntu systems.",
        timeout=120,
        can_fail=True,
        on_failure="abort",
        inputs=['apt package manager', 'internet connection', 'root/sudo privileges'],
        outputs=['sqlite3 binary installed', '/usr/bin/sqlite3 executable', 'SQLite3 system libraries']
    ),
    StepConfig(
        name="09-configure-network.sh",
        script="09-configure-network.sh",
        state=State.09_CONFIGURE_NETWORK_SH,
        description="Configures network interface for traffic mirroring by disabling all interfaces except the designated",
        timeout=30,
        can_fail=True,
        on_failure="abort",
        inputs=['MIRROR_INTERFACE environment variable (defaults to eth0)', 'system network interfaces', 'root privileges'],
        outputs=['disabled non-mirror network interfaces', 'promiscuous mode enabled on mirror interface', 'system ready for network monitoring']
    ),
    StepConfig(
        name="workflow_analyzer.py",
        script="workflow_analyzer.py",
        state=State.WORKFLOW_ANALYZER_PY,
        description="An advanced workflow analyzer that uses AI to analyze project files, detect bugs, generate finite st",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['ANTHROPIC_API_KEY environment variable or hardcoded key', 'root_dir directory to analyze (/home/tor/Downloads/ids2)', 'Project files with extensions: .py, .sh, .yml, .yaml, .service, .bash'],
        outputs=['workflow_analysis.html - Interactive multi-tab HTML report', 'workflow_analysis_cache.json - Cached analysis results', 'Console output with colored logging']
    ),
    StepConfig(
        name="10-install-backend-deps.sh",
        script="10-install-backend-deps.sh",
        state=State.10_INSTALL_BACKEND_DEPS_SH,
        description="Installs Python backend dependencies in a virtual environment by creating a venv and installing pack",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['REMOTE_DIR environment variable', 'requirements.txt file', 'python3 binary'],
        outputs=['virtual environment directory', 'installed Python packages', 'upgraded pip']
    ),
    StepConfig(
        name="03-install-python.sh",
        script="03-install-python.sh",
        state=State.03_INSTALL_PYTHON_SH,
        description="Installs Python 3 and related development packages on a Debian/Ubuntu system using apt-get.",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['Debian/Ubuntu system', 'root/sudo privileges', 'internet connectivity'],
        outputs=['python3 binary', 'python3-venv module', 'python3-pip package manager']
    ),
    StepConfig(
        name="04-install-node.sh",
        script="04-install-node.sh",
        state=State.04_INSTALL_NODE_SH,
        description="Installs Node.js and npm packages on a Debian-based system using apt-get package manager.",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'internet connection', 'debian-based OS'],
        outputs=['nodejs binary', 'npm binary', '/usr/bin/node']
    ),
    StepConfig(
        name="main.py",
        script="main.py",
        state=State.MAIN_PY,
        description="Main deployment script for a webapp backend that handles SSH deployment to Raspberry Pi and AWS Open",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['config.yaml', 'secrets.json', 'SSH keys'],
        outputs=['.env files', 'deployed backend services', 'remote configurations']
    ),
    StepConfig(
        name="11-install-frontend-deps.sh",
        script="11-install-frontend-deps.sh",
        state=State.11_INSTALL_FRONTEND_DEPS_SH,
        description="Installs npm dependencies for the frontend webapp by running 'npm install' in the frontend directory",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['REMOTE_DIR env var', 'INSTALL_USER env var', 'SUDO_USER env var'],
        outputs=['node_modules directory', 'installed frontend dependencies', 'package-lock.json']
    ),
    StepConfig(
        name="deploy.py",
        script="deploy.py",
        state=State.DEPLOY_PY,
        description="Deployment script that uploads code to a Raspberry Pi via SSH/SFTP and configures it as a systemd se",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['SSH host IP', 'SSH username', 'SSH password'],
        outputs=['secret.json file', 'deployed code on remote server', 'configured systemd service']
    ),
]

# =============================================================================
# EXECUTOR
# =============================================================================

class UnifiedExecutor:
    def __init__(self, project_dir: str = "."):
        self.project_dir = Path(project_dir).resolve()
        self.current_state = State.START
        self.execution_log: List[dict] = []
        self.start_time = time.time()
        self.lock_file = self.project_dir / ".unified_executor.lock"
        self._shutdown_requested = False
        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully."""
        self._shutdown_requested = True
        log.warning(f"Received signal {signum}, shutting down gracefully...")
        
    def _run_script(self, step: StepConfig) -> bool:
        """Ex√©cute un script avec gestion des erreurs et timeout."""
        script_path = self.project_dir / step.script
        
        if not script_path.exists():
            log.warning(f"Script non trouv√©: {step.script}")
            return step.on_failure == "skip"
        
        log.info(f"‚ñ∂ Ex√©cution: {step.script}")
        log.info(f"  Description: {step.description}")
        
        # Pr√©parer la commande avec v√©rification des ex√©cutables
        if step.script.endswith('.py'):
            if not shutil.which(sys.executable):
                log.error(f"Python executable not found: {sys.executable}")
                return False
            cmd = [sys.executable, str(script_path)]
        elif step.script.endswith(('.sh', '.bash')):
            bash_path = shutil.which('bash')
            if not bash_path:
                log.error("bash executable not found")
                return False
            cmd = [bash_path, str(script_path)]
        else:
            cmd = [str(script_path)]
            # Check if script is executable
            if not os.access(script_path, os.X_OK):
                log.error(f"Script is not executable: {script_path}")
                return False
        
        # Ex√©cuter avec timeout
        retries = 0
        while retries <= step.max_retries:
            try:
                start = time.time()
                result = subprocess.run(
                    cmd,
                    cwd=str(self.project_dir),
                    timeout=step.timeout,
                    capture_output=True,
                    text=True,
                    env={**os.environ, 'PYTHONPATH': str(self.project_dir)}
                )
                duration = time.time() - start
                
                if result.returncode == 0:
                    log.info(f"  ‚úÖ Succ√®s en {duration:.1f}s")
                    self.execution_log.append({
                        'step': step.name,
                        'status': 'success',
                        'duration': duration
                    })
                    return True
                else:
                    log.error(f"  ‚ùå √âchec (code {result.returncode})")
                    if result.stderr:
                        log.error(f"  Erreur: {result.stderr[:500]}")
                    
                    if step.on_failure == "retry" and retries < step.max_retries:
                        retries += 1
                        log.info(f"  üîÑ Retry {retries}/{step.max_retries}...")
                        time.sleep(2)
                        continue
                    elif step.on_failure == "skip":
                        log.warning(f"  ‚è≠Ô∏è Skip (non critique)")
                        return True
                    else:
                        return False
                        
            except subprocess.TimeoutExpired:
                log.error(f"  ‚è∞ Timeout apr√®s {step.timeout}s")
                if step.on_failure == "skip":
                    return True
                return False
            except Exception as e:
                log.error(f"  üí• Exception: {e}")
                return False
        
        return False
    
    def run(self, start_from: Optional[str] = None, dry_run: bool = False) -> bool:
        """Ex√©cute tous les steps dans l'ordre."""
        # File locking to prevent concurrent executions
        import fcntl
        try:
            lock_fd = self.lock_file.open('w')
            try:
                fcntl.flock(lock_fd.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            except BlockingIOError:
                log.error(f"Another instance is already running (lock file: {self.lock_file})")
                return False
        except Exception as e:
            log.warning(f"Could not acquire lock file: {e}. Continuing anyway...")
            lock_fd = None
        
        try:
            log.info("=" * 60)
            log.info("UNIFIED EXECUTION - START")
            log.info(f"Project: {self.project_dir}")
            log.info(f"Steps: {len(EXECUTION_STEPS)}")
            log.info("=" * 60)
        
        started = start_from is None
        
        for i, step in enumerate(EXECUTION_STEPS, 1):
            if not started:
                if step.script == start_from:
                    started = True
                else:
                    continue
            
            log.info(f"\n[{i}/{len(EXECUTION_STEPS)}] {step.state.name}")
            
            if dry_run:
                log.info(f"  [DRY-RUN] Would execute: {step.script}")
                continue
            
            self.current_state = step.state
            
            # Check for shutdown request
            if self._shutdown_requested:
                log.warning("Shutdown requested, stopping execution...")
                self.current_state = State.ERROR
                self._print_summary()
                return False
            
            if not self._run_script(step):
                log.error(f"\nüíÄ EXECUTION FAILED at step: {step.name}")
                self.current_state = State.ERROR
                self._print_summary()
                return False
        
        self.current_state = State.SUCCESS
        log.info("\n" + "=" * 60)
        log.info("‚ú® ALL STEPS COMPLETED SUCCESSFULLY")
        log.info("=" * 60)
        
        self._print_summary()
        return True
        finally:
            # Release lock
            if lock_fd is not None:
                try:
                    fcntl.flock(lock_fd.fileno(), fcntl.LOCK_UN)
                    lock_fd.close()
                    self.lock_file.unlink(missing_ok=True)
                except Exception:
                    pass
    
    def _print_summary(self):
        """Affiche le r√©sum√© d'ex√©cution."""
        duration = time.time() - self.start_time
        log.info(f"\nüìä SUMMARY")
        log.info(f"  Total duration: {duration:.1f}s")
        log.info(f"  Final state: {self.current_state.name}")
        log.info(f"  Steps executed: {len(self.execution_log)}")
        
        success = sum(1 for l in self.execution_log if l['status'] == 'success')
        log.info(f"  Successful: {success}/{len(self.execution_log)}")

# =============================================================================
# MAIN
# =============================================================================

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Unified Execution Script")
    parser.add_argument('--dry-run', action='store_true', help='Simulation sans ex√©cution')
    parser.add_argument('--start-from', type=str, help='D√©marrer √† partir de ce script')
    parser.add_argument('--list', action='store_true', help='Lister les √©tapes')
    parser.add_argument('-d', '--dir', default='.', help='R√©pertoire du projet')
    
    args = parser.parse_args()
    
    if args.list:
        print("\nüìã √âTAPES D'EX√âCUTION:\n")
        for i, step in enumerate(EXECUTION_STEPS, 1):
            print(f"  {i:2d}. [{step.state.name:15s}] {step.script}")
            print(f"      {step.description}")
        return
    
    executor = UnifiedExecutor(args.dir)
    success = executor.run(start_from=args.start_from, dry_run=args.dry_run)
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
