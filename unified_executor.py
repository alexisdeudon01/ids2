#!/usr/bin/env python3
"""
=============================================================================
UNIFIED EXECUTION SCRIPT - Auto-generated by Workflow Analyzer
=============================================================================
Ce script exÃ©cute tous les scripts du projet dans l'ordre optimal.
GÃ©nÃ©rÃ© le: 2026-02-05 00:16:50
=============================================================================
"""

import os
import sys
import subprocess
import time
import signal
from pathlib import Path
from enum import Enum, auto
from dataclasses import dataclass
from typing import Optional, List, Callable
import logging

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-8s | %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('unified_execution.log')
    ]
)
log = logging.getLogger(__name__)

# =============================================================================
# FSM STATES
# =============================================================================

class State(Enum):
    START = auto()
    UNIFIED_EXECUTOR_PY = auto()
    SETUP_SH = auto()
    01_UPDATE_UPGRADE_SH = auto()
    02_INSTALL_BASE_SH = auto()
    SETUP_VENV_SH = auto()
    00_CHECK_APT_SOURCES_SH = auto()
    05_INSTALL_DOCKER_SH = auto()
    03_INSTALL_PYTHON_SH = auto()
    MAIN_PY = auto()
    07_INSTALL_PIGPIO_SH = auto()
    08_INSTALL_SQLITE_SH = auto()
    10_INSTALL_BACKEND_DEPS_SH = auto()
    DEPLOY_PY = auto()
    11_INSTALL_FRONTEND_DEPS_SH = auto()
    09_CONFIGURE_NETWORK_SH = auto()
    06_INSTALL_SURICATA_SH = auto()
    04_INSTALL_NODE_SH = auto()
    BUILD_IMAGES_SH = auto()
    WORKFLOW_ANALYZER_PY = auto()
    SUCCESS = auto()
    ERROR = auto()

# =============================================================================
# CONFIGURATION
# =============================================================================

@dataclass
class StepConfig:
    name: str
    script: str
    state: State
    description: str
    timeout: int = 300
    can_fail: bool = True
    on_failure: str = "abort"  # abort, skip, retry
    max_retries: int = 3
    inputs: List[str] = None
    outputs: List[str] = None

EXECUTION_STEPS: List[StepConfig] = [
    StepConfig(
        name="unified_executor.py",
        script="unified_executor.py",
        state=State.UNIFIED_EXECUTOR_PY,
        description="Auto-generated unified execution script that runs all project scripts in optimal order with state ma",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['EXECUTION_STEPS configuration', 'project_dir path', 'PYTHONPATH environment'],
        outputs=['unified_execution.log', 'execution state changes', 'orchestrated script results']
    ),
    StepConfig(
        name="setup.sh",
        script="setup.sh",
        state=State.SETUP_SH,
        description="Remote deployment script that packages the current directory and installs it on a Raspberry Pi via S",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['current directory source code', 'user input for Pi credentials', 'SSH connectivity to target Pi'],
        outputs=['deployed application on Raspberry Pi', 'configured services', 'extracted files in remote directory']
    ),
    StepConfig(
        name="01-update-upgrade.sh",
        script="01-update-upgrade.sh",
        state=State.01_UPDATE_UPGRADE_SH,
        description="Updates and upgrades Debian/Ubuntu system packages using apt-get with comprehensive error handling a",
        timeout=600,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'apt-get package manager', 'network connectivity'],
        outputs=['updated package lists', 'upgraded system packages', 'system state ready for installations']
    ),
    StepConfig(
        name="02-install-base.sh",
        script="02-install-base.sh",
        state=State.02_INSTALL_BASE_SH,
        description="A base system package installer that installs essential development tools and certificates on Debian",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'internet connectivity', 'Debian/Ubuntu system'],
        outputs=['installed packages: ca-certificates, curl, gnupg, lsb-release, build-essential, jq', 'updated apt package lists', 'restored DEBIAN_FRONTEND environment variable']
    ),
    StepConfig(
        name="setup_venv.sh",
        script="setup_venv.sh",
        state=State.SETUP_VENV_SH,
        description="Sets up a Python virtual environment, installs dependencies from requirements.txt if present, and co",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['python3 binary', 'python3-venv module', 'requirements.txt (optional)'],
        outputs=['venv/ directory with Python virtual environment', 'installed Python packages', 'updated .gitignore file']
    ),
    StepConfig(
        name="00-check-apt-sources.sh",
        script="00-check-apt-sources.sh",
        state=State.00_CHECK_APT_SOURCES_SH,
        description="Validates the presence and configuration of APT package sources on Debian/Ubuntu systems before pack",
        timeout=10,
        can_fail=True,
        on_failure="abort",
        inputs=['/etc/apt directory structure', '/etc/apt/sources.list file', '/etc/apt/sources.list.d/*.list files'],
        outputs=['exit code 0 for success', 'exit code 1 for failure', 'console messages in French']
    ),
    StepConfig(
        name="05-install-docker.sh",
        script="05-install-docker.sh",
        state=State.05_INSTALL_DOCKER_SH,
        description="Installs Docker Engine on Debian/Ubuntu systems with DNS configuration, user group setup, and system",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['INSTALL_USER env var', 'SUDO_USER env var', 'USER env var'],
        outputs=['Docker Engine installation', '/etc/docker/daemon.json config', 'docker group membership']
    ),
    StepConfig(
        name="03-install-python.sh",
        script="03-install-python.sh",
        state=State.03_INSTALL_PYTHON_SH,
        description="Installs Python 3 and related development tools (pip, venv, dev headers) on Debian/Ubuntu systems us",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'apt-get package manager', 'internet connectivity'],
        outputs=['python3 binary', 'python3-pip', 'python3-venv']
    ),
    StepConfig(
        name="main.py",
        script="main.py",
        state=State.MAIN_PY,
        description="Main deployment and management script for a webapp backend. Handles SSH deployment, configuration ma",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['SSH credentials', 'deployment configuration', 'REMOTE_DIR env var'],
        outputs=['deployed application', 'SSH connections', 'remote file transfers']
    ),
    StepConfig(
        name="07-install-pigpio.sh",
        script="07-install-pigpio.sh",
        state=State.07_INSTALL_PIGPIO_SH,
        description="Installs pigpio GPIO library from source with comprehensive error handling and systemd service setup",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'internet connectivity', 'PIGPIO_ARCHIVE_URL env var (optional)'],
        outputs=['pigpio library binaries', 'pigpiod daemon', '/etc/systemd/system/pigpiod.service']
    ),
    StepConfig(
        name="08-install-sqlite.sh",
        script="08-install-sqlite.sh",
        state=State.08_INSTALL_SQLITE_SH,
        description="This script installs SQLite3 database system on Debian/Ubuntu systems with comprehensive error handl",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'apt-get package manager', 'network connectivity'],
        outputs=['sqlite3 binary installed', 'sqlite3 command available in PATH', 'version output to stdout']
    ),
    StepConfig(
        name="10-install-backend-deps.sh",
        script="10-install-backend-deps.sh",
        state=State.10_INSTALL_BACKEND_DEPS_SH,
        description="Installs Python backend dependencies in a virtual environment with error handling and retry mechanis",
        timeout=600,
        can_fail=True,
        on_failure="abort",
        inputs=['REMOTE_DIR environment variable', 'webapp/backend/requirements.txt', 'python3 binary'],
        outputs=['webapp/backend/venv/ directory', 'installed Python packages', 'upgraded pip']
    ),
    StepConfig(
        name="deploy.py",
        script="deploy.py",
        state=State.DEPLOY_PY,
        description="SSH-based deployment script that uploads code to a Raspberry Pi and configures it as a systemd servi",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['SSH credentials via prompts', 'Raspberry Pi IP address', 'sudo password'],
        outputs=['secret.json file', 'uploaded code on remote server', 'configured systemd service']
    ),
    StepConfig(
        name="11-install-frontend-deps.sh",
        script="11-install-frontend-deps.sh",
        state=State.11_INSTALL_FRONTEND_DEPS_SH,
        description="Installs frontend dependencies using npm for the IDS dashboard project with retry logic and network ",
        timeout=300,
        can_fail=True,
        on_failure="retry",
        inputs=['REMOTE_DIR env var', 'INSTALL_USER env var', 'SUDO_USER env var'],
        outputs=['node_modules directory', 'package-lock.json', 'installed npm packages']
    ),
    StepConfig(
        name="09-configure-network.sh",
        script="09-configure-network.sh",
        state=State.09_CONFIGURE_NETWORK_SH,
        description="Configures network interfaces for packet mirroring by disabling all interfaces except the specified ",
        timeout=30,
        can_fail=True,
        on_failure="abort",
        inputs=['MIRROR_INTERFACE environment variable', 'root/sudo privileges', 'iproute2 package'],
        outputs=['disabled network interfaces', 'promiscuous mode enabled on mirror interface', 'network configuration changes']
    ),
    StepConfig(
        name="06-install-suricata.sh",
        script="06-install-suricata.sh",
        state=State.06_INSTALL_SURICATA_SH,
        description="Installs Suricata IDS/IPS system and updates its rules database on Debian/Ubuntu systems. Handles pr",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['root/sudo privileges', 'apt-get package manager', 'network connectivity'],
        outputs=['suricata binary installed', 'suricata-update tool installed', 'updated Suricata rule database']
    ),
    StepConfig(
        name="04-install-node.sh",
        script="04-install-node.sh",
        state=State.04_INSTALL_NODE_SH,
        description="Installs Node.js and npm on Debian/Ubuntu systems with privilege checks, network validation, and ret",
        timeout=300,
        can_fail=True,
        on_failure="abort",
        inputs=['sudo/root privileges', 'apt-get package manager', 'internet connectivity'],
        outputs=['nodejs binary', 'npm binary', 'Node.js runtime environment']
    ),
    StepConfig(
        name="build-images.sh",
        script="build-images.sh",
        state=State.BUILD_IMAGES_SH,
        description="Builds multiple Docker images for the IDS2 system in a specific order, starting with a base Python i",
        timeout=1800,
        can_fail=True,
        on_failure="abort",
        inputs=['docker daemon', 'Dockerfiles in docker/ subdirectories', 'source code in parent directory'],
        outputs=['Docker images: ids2-python-base, ids2-runtime, ids2-fastapi, ids2-vector, ids2-redis, ids2-prometheus, ids2-grafana, ids2-cadvisor, ids2-node-exporter', 'image list output']
    ),
    StepConfig(
        name="workflow_analyzer.py",
        script="workflow_analyzer.py",
        state=State.WORKFLOW_ANALYZER_PY,
        description="A comprehensive Python utility that analyzes workflow files using AI to detect bugs, generate FSMs, ",
        timeout=1800,
        can_fail=True,
        on_failure="abort",
        inputs=['ANTHROPIC_API_KEY or hardcoded API key', 'Source code files (.py, .sh, .yml, .yaml, .service, .bash)', 'Directory structure to analyze'],
        outputs=['workflow_analysis.html with interactive visualization', 'workflow_analysis_cache.json with analysis results', 'Terminal output with progress monitoring']
    ),
]

# =============================================================================
# EXECUTOR
# =============================================================================

class UnifiedExecutor:
    def __init__(self, project_dir: str = "."):
        self.project_dir = Path(project_dir).resolve()
        self.current_state = State.START
        self.execution_log: List[dict] = []
        self.start_time = time.time()
        
    def _run_script(self, step: StepConfig) -> bool:
        """ExÃ©cute un script avec gestion des erreurs et timeout."""
        script_path = self.project_dir / step.script
        
        if not script_path.exists():
            log.warning(f"Script non trouvÃ©: {step.script}")
            return step.on_failure == "skip"
        
        log.info(f"â–¶ ExÃ©cution: {step.script}")
        log.info(f"  Description: {step.description}")
        
        # PrÃ©parer la commande
        if step.script.endswith('.py'):
            cmd = [sys.executable, str(script_path)]
        elif step.script.endswith(('.sh', '.bash')):
            cmd = ['bash', str(script_path)]
        else:
            cmd = [str(script_path)]
        
        # ExÃ©cuter avec timeout
        retries = 0
        while retries <= step.max_retries:
            try:
                start = time.time()
                result = subprocess.run(
                    cmd,
                    cwd=str(self.project_dir),
                    timeout=step.timeout,
                    capture_output=True,
                    text=True,
                    env={**os.environ, 'PYTHONPATH': str(self.project_dir)}
                )
                duration = time.time() - start
                
                if result.returncode == 0:
                    log.info(f"  âœ… SuccÃ¨s en {duration:.1f}s")
                    self.execution_log.append({
                        'step': step.name,
                        'status': 'success',
                        'duration': duration
                    })
                    return True
                else:
                    log.error(f"  âŒ Ã‰chec (code {result.returncode})")
                    if result.stderr:
                        log.error(f"  Erreur: {result.stderr[:500]}")
                    
                    if step.on_failure == "retry" and retries < step.max_retries:
                        retries += 1
                        log.info(f"  ðŸ”„ Retry {retries}/{step.max_retries}...")
                        time.sleep(2)
                        continue
                    elif step.on_failure == "skip":
                        log.warning(f"  â­ï¸ Skip (non critique)")
                        return True
                    else:
                        return False
                        
            except subprocess.TimeoutExpired:
                log.error(f"  â° Timeout aprÃ¨s {step.timeout}s")
                if step.on_failure == "skip":
                    return True
                return False
            except Exception as e:
                log.error(f"  ðŸ’¥ Exception: {e}")
                return False
        
        return False
    
    def run(self, start_from: Optional[str] = None, dry_run: bool = False) -> bool:
        """ExÃ©cute tous les steps dans l'ordre."""
        log.info("=" * 60)
        log.info("UNIFIED EXECUTION - START")
        log.info(f"Project: {self.project_dir}")
        log.info(f"Steps: {len(EXECUTION_STEPS)}")
        log.info("=" * 60)
        
        started = start_from is None
        
        for i, step in enumerate(EXECUTION_STEPS, 1):
            if not started:
                if step.script == start_from:
                    started = True
                else:
                    continue
            
            log.info(f"\n[{i}/{len(EXECUTION_STEPS)}] {step.state.name}")
            
            if dry_run:
                log.info(f"  [DRY-RUN] Would execute: {step.script}")
                continue
            
            self.current_state = step.state
            
            if not self._run_script(step):
                log.error(f"\nðŸ’€ EXECUTION FAILED at step: {step.name}")
                self.current_state = State.ERROR
                self._print_summary()
                return False
        
        self.current_state = State.SUCCESS
        log.info("\n" + "=" * 60)
        log.info("âœ¨ ALL STEPS COMPLETED SUCCESSFULLY")
        log.info("=" * 60)
        
        self._print_summary()
        return True
    
    def _print_summary(self):
        """Affiche le rÃ©sumÃ© d'exÃ©cution."""
        duration = time.time() - self.start_time
        log.info(f"\nðŸ“Š SUMMARY")
        log.info(f"  Total duration: {duration:.1f}s")
        log.info(f"  Final state: {self.current_state.name}")
        log.info(f"  Steps executed: {len(self.execution_log)}")
        
        success = sum(1 for l in self.execution_log if l['status'] == 'success')
        log.info(f"  Successful: {success}/{len(self.execution_log)}")

# =============================================================================
# MAIN
# =============================================================================

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Unified Execution Script")
    parser.add_argument('--dry-run', action='store_true', help='Simulation sans exÃ©cution')
    parser.add_argument('--start-from', type=str, help='DÃ©marrer Ã  partir de ce script')
    parser.add_argument('--list', action='store_true', help='Lister les Ã©tapes')
    parser.add_argument('-d', '--dir', default='.', help='RÃ©pertoire du projet')
    
    args = parser.parse_args()
    
    if args.list:
        print("\nðŸ“‹ Ã‰TAPES D'EXÃ‰CUTION:\n")
        for i, step in enumerate(EXECUTION_STEPS, 1):
            print(f"  {i:2d}. [{step.state.name:15s}] {step.script}")
            print(f"      {step.description}")
        return
    
    executor = UnifiedExecutor(args.dir)
    success = executor.run(start_from=args.start_from, dry_run=args.dry_run)
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
